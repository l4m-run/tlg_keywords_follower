# План миграции на Docker

## 1. Цели

- Упаковать сервис `tlg_keywords_follower` в Docker контейнер.
- Обеспечить предсказуемость окружения (Python версия, зависимости).
- Упростить деплой и обновление (одной командой).
- Обеспечить сохранность данных (сессии, конфиги, очередь) при пересоздании контейнеров.

## 2. Структура изменений

### 2.1. Dockerfile

Создать `Dockerfile` в корне проекта:

- Базовый образ: `python:3.11-slim` (или 3.12).
- Установка зависимостей из `requirements.txt`.
- Создание непривилегированного пользователя для запуска бота.
- Настройка рабочей директории.

### 2.2. docker-compose.yml

Создать `docker-compose.yml` для управления сервисом:

- Сервис `bot`.
- **Volumes** (монтирование):
  - `./config.json:/app/config.json` (конфиг)
  - `./rules.txt:/app/rules.txt` (правила)
  - `./queue:/app/queue` (очередь сообщений)
  - `./.env:/app/.env` (секреты)
  - `./session:/app/session` (папка для сессий, нужно будет перенести сессии туда или монтировать файлы)
    - *Примечание*: Telethon создает файл сессии в корне по умолчанию. В докере лучше выделить папку для состояния, например `/app/data`, и монтировать её. Или просто монтировать текущую директорию (но это "грязно").
    - **Решение**: Монтировать конкретные файлы сессий или настроить путь к сессии в конфиге/коде. Для простоты: монтировать volume `./sessions:/app/sessions` и научить бота искать сессию там.
- **Restart policy**: `unless-stopped`.
- **Log driver**: json-file с ротацией.

### 2.3. Изменения в коде

- Убедиться, что `main.py` корректно работает внутри контейнера (пути к файлам).
- Желательно (не обязательно, но полезно) научить бота брать путь к сессии из переменной окружения или конфига, чтобы хранить их в отдельной папке `sessions/`.

### 2.4. Скрипты деплоя

- Обновить `deploy.sh` или создать `deploy_docker.sh`:
  - Проверка наличия Docker и Docker Compose.
  - `docker-compose up -d --build`.
  - Логирование.

## 3. Этапы реализации

### Этап 1: Подготовка (Локально)

1. [ ] Создать `Dockerfile`.
2. [ ] Создать `docker-compose.yml`.
3. [ ] Создать `.dockerignore` (исключить `.venv`, `.git`, `__pycache__`).
4. [ ] Тестовый запуск локально. Проверка авторизации (интерактивный ввод кода при первом запуске может быть сложен в докере без `stdin_open` и `tty`, поэтому сессию лучше создавать локально и копировать, либо запускать `docker-compose run` для первого входа).

### Этап 2: Доработка деплоя

1. [ ] Написать скрипт запуска `run_docker.sh`.
2. [ ] Добавить инструкции в `README.md` (раздел "Docker Quickstart").

## 4. Примерная конфигурация

**Dockerfile**:

```dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# Создаем пользователя, чтобы не запускать от root
RUN useradd -m botuser && chown -R botuser /app
USER botuser

CMD ["python", "main.py"]
```

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  bot:
    build: .
    container_name: tlg_keywords_follower
    restart: unless-stopped
    volumes:
      - ./config.json:/app/config.json
      - ./rules.txt:/app/rules.txt
      - ./queue:/app/queue
      - ./.env:/app/.env
      # Монтируем файлы сессий (лучше папку, если адаптируем код)
      - ./*.session:/app/*.session 
      - ./*.session-journal:/app/*.session-journal
    environment:
      - PYTHONUNBUFFERED=1
```

*Важно: wildcard mount (`*.session`) в volumes не поддерживается docker-compose напрямую так просто. Лучше монтировать всю папку данных или перенести сессии в подпапку.*

## 5. Риски

- Переавторизация: Если перенести файл сессии некорректно, сессия сбросится.
- FloodWait: При частых перезапусках контейнера возможны временные баны от Telegram.

## 6. Итоговый результат

Проект можно запустить одной командой `docker-compose up -d`, при этом данные сохраняются.
